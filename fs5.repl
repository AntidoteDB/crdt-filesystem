// used types
idtype NodeId
idtype UserId
idtype GroupId
type String

type getFileResult =
    notFound()
  | found(name: String)
 
type createFileResult = 
    fail()
    | newFile(fileId: NodeId)
    
// TODO: use in the model/procs
type accesRights = 
    None() // 000
    | R()  // 100
    | W()  // 010
    | X()  // 001
    | RW() // 110
    | RX() // 101
    | WX() // 011
    | RWX()// 111

// CRDT specifications
// this data will represent file and directory
// we name it file since we assumed directory is a file which has childrens (it can be non sence assumtion but we used it just to make it easy to accept the name)
crdt files: Map_uw[NodeId, {
    // this field will show is it a directory or file
    is_dir: Register[Bool],
    name: Register[String],
    // this field will contain node id of directory. we can use it to find all childrens of directory
    parent: Register[NodeId],
    owner_bit: Register[Int],
    group_bit: Register[Int],
    other_bit: Register[Int],
    file_owner: Register[UserId],
    file_group: Register[GroupId]
}]

crdt groups: Map_dw[GroupId, {
    group_users: Set_rw[UserId]
}]

crdt users: Map_uw[UserId, {
    is_admin: Register[Bool],
    user_group: Register[GroupId] // own group
}]

def changeOwner(userId: UserId, newOwnerId: UserId, fileId: NodeId): Bool
    atomic 
        if (filesQry(ContainsKey(fileId)))
            if (usersQry(ContainsKey(userId)) && usersQry(NestedQuery(userId, is_adminQry(ReadRegister))))
                call files(NestedOp(fileId, file_owner(Assign(newOwnerId))))
                return true

        return false


def changeGroup(userId: UserId, newGroupId: GroupId, fileId: NodeId): Bool // CRASHES
    atomic
        if (filesQry(ContainsKey(fileId)))
            if(
                (usersQry(ContainsKey(userId)) && usersQry(NestedQuery(userId, is_adminQry(ReadRegister))))
                || (filesQry(NestedQuery(fileId, file_ownerQry(ReadRegister))) == userId && groupsQry(NestedQuery(newGroupId, group_usersQry(Contains(userId)))))
            )
                call files(NestedOp(fileId, file_group(Assign(newGroupId))))
                return true

        return false


// def changeOwnerPermission(userId: UserId, newPermission: Int, fileId: NodeId): Bool
//     atomic
//         if (filesQry(ContainsKey(fileId)))
//             if(
//                 (usersQry(ContainsKey(userId)) && usersQry(NestedQuery(userId, is_adminQry(ReadRegister))))
//                 || filesQry(NestedQuery(fileId, file_ownerQry(ReadRegister))) == userId
//             )
//                 call files(NestedOp(fileId, owner_bit(Assign(newPermission))))
//                 assert filesQry(NestedQuery(fileId, owner_bitQry(ReadRegister))) >= 0 && filesQry(NestedQuery(fileId, owner_bitQry(ReadRegister))) <= 7
//                 return true

//         return false


// def changeGroupPermission(userId: UserId, newPermission: Int, fileId: NodeId): Bool
//     atomic
//         if (filesQry(ContainsKey(fileId)))
//             if(
//                 (usersQry(ContainsKey(userId)) && usersQry(NestedQuery(userId, is_adminQry(ReadRegister))))
//                 || filesQry(NestedQuery(fileId, file_ownerQry(ReadRegister))) == userId
//             )
//                 call files(NestedOp(fileId, group_bit(Assign(newPermission))))
//                 assert filesQry(NestedQuery(fileId, group_bitQry(ReadRegister))) >= 0 && filesQry(NestedQuery(fileId, group_bitQry(ReadRegister))) <= 7
//                 return true

//         return false


// def changeOtherPermission(userId: UserId, newPermission: Int, fileId: NodeId): Bool
//     atomic 
//         if (filesQry(ContainsKey(fileId)))
//             if(
//                 (usersQry(ContainsKey(userId)) && usersQry(NestedQuery(userId, is_adminQry(ReadRegister))))
//                 || filesQry(NestedQuery(fileId, file_ownerQry(ReadRegister))) == userId
//             )
//                 call files(NestedOp(fileId, other_bit(Assign(newPermission))))
//                 assert filesQry(NestedQuery(fileId, other_bitQry(ReadRegister))) >= 0 && filesQry(NestedQuery(fileId, other_bitQry(ReadRegister))) <= 7
//                 return true

//         return false

// def createFile(userId: UserId, directoryId: NodeId): createFileResult
//     var f: NodeId
//     atomic
//         if ((filesQry(ContainsKey(directoryId))))
//             if(
//                     usersQry(NestedQuery(userId, is_adminQry(ReadRegister)))
//                 ||  ( filesQry(NestedQuery(directoryId, file_ownerQry(ReadRegister))) == userId &&
//                         (
//                                 filesQry(NestedQuery(directoryId, owner_bitQry(ReadRegister))) == 3
//                             ||  filesQry(NestedQuery(directoryId, owner_bitQry(ReadRegister))) == 7
//                         )
//                     ) //has write and exectue rights to directory
//                 ||  ( filesQry(NestedQuery(directoryId, file_groupQry(ReadRegister))) == usersQry(NestedQuery(userId, user_groupQry(ReadRegister))) &&
//                         (
//                                 filesQry(NestedQuery(directoryId, group_bitQry(ReadRegister))) == 3
//                             ||  filesQry(NestedQuery(directoryId, group_bitQry(ReadRegister))) == 7     
//                         )
//                     ) //has write and exectue rights to directory group access
//             ) 
//                 f = new NodeId
//                 // call file_name_assign(f, fileName) // file name
//                 call files(NestedOp(f, owner_bit(Assign(7)))) //default rwx for owner
//                 call files(NestedOp(f, group_bit(Assign(4)))) //default r   for group
//                 call files(NestedOp(f, other_bit(Assign(4)))) //default r   for other
//                 call files(NestedOp(f, file_owner(Assign(userId)))) //associate a user
//                 call files(NestedOp(f, file_group(Assign( usersQry(NestedQuery(userId, user_groupQry(ReadRegister))) )))) //associate group to user
//                 return newFile(f)

//         return fail()



def instantiateRootDir(): NodeId
    var f: NodeId
    atomic
        f = new NodeId
        call files(NestedOp(f, owner_bit(Assign(7))))
        call files(NestedOp(f, group_bit(Assign(7))))
        call files(NestedOp(f, other_bit(Assign(7))))
        call files(NestedOp(f, parent(Assign(f))))
        call files(NestedOp(f, is_dir(Assign(true))))
        // call file_name_assign(f, fileName) // file name
        // call file_owner_assign(f, user)  //  associate a user
        // call file_group_assign(f, group) //  associate group to user
        return f

def createUser(with_admin_rights: Bool) : UserId
    var u: UserId
    var g: GroupId
    atomic
        u = new UserId
        g = new GroupId
        call users(NestedOp(u, is_admin(Assign(with_admin_rights))))
        call users(NestedOp(u, user_group(Assign(g))))
        call groups(NestedOp(g, group_users(Add(u))))
        return u


// def assignUserToGroup(adminId: UserId, userId: UserId, groupId: GroupId) : Bool
//     var g: GroupId
//     atomic
//         if ((usersQry(ContainsKey(adminId)) && usersQry(NestedQuery(adminId, is_adminQry(ReadRegister)))) && usersQry(ContainsKey(userId)))
//             g = new GroupId
//             call groups(NestedOp(groupId, group_users(Add(userId)))) // it will add group if it is does not exist
//             return true

//         return false


// def removeUserFromGroup(adminId: UserId, userId: UserId, groupId: GroupId) : Bool
//     atomic
//         if (((usersQry(ContainsKey(adminId))) && usersQry(NestedQuery(adminId, is_adminQry(ReadRegister)))) && usersQry(ContainsKey(userId)))
//             call groups(NestedOp(groupId, group_users(Remove(userId))))
//             return true

//         return false

 
// // application specification:
// invariant forall changeOwnerPermissionInvocation: InvocationId, fileId: NodeId, userId: UserId, newPermission: Int  ::
//         exists changeOwnerPermissionCall: CallId ::
//             changeOwnerPermissionCall.op == Op(files(NestedOp(fileId, owner_bit(Assign(newPermission))))) // changeOwnerPermissions on `file`
//         &&  changeOwnerPermissionCall.origin == changeOwnerPermissionInvocation                         // bind to the invocationid
//         &&  changeOwnerPermissionInvocation.info == changeOwnerPermission(userId, newPermission, fileId)    // the invocation of the call(crucial for capturing which user called this)
//         &&  changeOwnerPermissionInvocation.result == changeOwnerPermission_res(true)                   // success (the procedure which does the action call of changing owner was successful)
//         ==>                                                               
//             exists assignAdmin: CallId ::
//                     assignAdmin.op == Op(users(NestedOp(userId, is_admin(Assign(true)))))
//                 &&  assignAdmin happened before changeOwnerPermissionCall
//             ||  
//             exists changeOwner: CallId ::
//                     changeOwner.op == Op(files(NestedOp(fileId, file_owner(Assign(userId)))))           // change owner to `user`
//                 &&  changeOwner is visible                                                          // which context is used here?


// invariant forall changeGroupPermissionInvocation: InvocationId, fileId: NodeId, userId: UserId, newPermission: Int  ::
//         exists changeGroupPermissionCall: CallId ::
//             changeGroupPermissionCall.op == Op(files(NestedOp(fileId, group_bit(Assign(newPermission)))))
//         &&  changeGroupPermissionCall.origin == changeGroupPermissionInvocation
//         &&  changeGroupPermissionInvocation.info == changeGroupPermission(userId, newPermission, fileId)
//         &&  changeGroupPermissionInvocation.result == changeGroupPermission_res(true)
//         ==>
//             exists assignAdmin: CallId ::
//                     assignAdmin.op == Op(users(NestedOp(userId, is_admin(Assign(true)))))
//                 &&  assignAdmin happened before changeGroupPermissionCall
//             ||
//             exists changeOwner: CallId  ::
//                     changeOwner.op == Op(files(NestedOp(fileId, file_owner(Assign(userId)))))
//                 &&  changeOwner is visible

// invariant forall changeOtherPermissionInvocation: InvocationId, fileId: NodeId, userId: UserId, newPermission: Int  ::
//         exists changeOtherPermissionCall: CallId ::
//             changeOtherPermissionCall.op == Op(files(NestedOp(fileId, other_bit(Assign(newPermission)))))
//         &&  changeOtherPermissionCall.origin == changeOtherPermissionInvocation
//         &&  changeOtherPermissionInvocation.info == changeOtherPermission(userId, newPermission, fileId)
//         &&  changeOtherPermissionInvocation.result == changeOtherPermission_res(true)
//         ==>
//             exists assignAdmin: CallId ::
//                     assignAdmin.op == Op(users(NestedOp(userId, is_admin(Assign(true)))))
//                 &&  assignAdmin happened before changeOtherPermissionCall
//             ||  
//             exists changeOwner: CallId  ::
//                     changeOwner.op == Op(files(NestedOp(fileId, file_owner(Assign(userId)))))
//                 &&  changeOwner is visible

// //availability
// //an allowed permission change passes
// invariant forall changeOwnerPermissionInvocation: InvocationId, fileId: NodeId, userId: UserId, newPermission: Int  ::
//         exists changeOwnerPermissionCall: CallId ::
//                 changeOwnerPermissionCall.op == Op(files(NestedOp(fileId, owner_bit(Assign(newPermission)))))
//             &&  changeOwnerPermissionCall.origin == changeOwnerPermissionInvocation
//             &&  changeOwnerPermissionInvocation.info == changeOwnerPermission(userId, newPermission, fileId)
//             && (
//                 exists assignAdmin: CallId ::
//                     assignAdmin.op == Op(users(NestedOp(userId, is_admin(Assign(true)))))
//                 &&  assignAdmin happened before changeOwnerPermissionCall
//                 ||  
//                 exists changeOwner: CallId  ::
//                         changeOwner.op == Op(files(NestedOp(fileId, file_owner(Assign(userId)))))
//                     &&  changeOwner is visible
//             )
//             ==> changeOwnerPermissionInvocation.result == changeOwnerPermission_res(true)


// invariant forall assignUserCall: CallId, userId: UserId ::
//     assignUserCall.op == Op(users(NestedOp(userId, is_admin(Assign(false)))))
//     ==> 
//         exists assignAdminCall: CallId, adminId: UserId ::
//                 assignAdminCall.op == Op(users(NestedOp(adminId, is_admin(Assign(true)))))
//             &&  adminId != userId
//             &&  assignAdminCall happened before assignUserCall
            
// invariant forall instantiateCall1: InvocationId, instantiateCall2: InvocationId ::
//     // TODO: bind to instantiate call
//     instantiateCall1 == instantiateCall2

// sanity tests
// invariant forall changeOwnerPermissionInvocation: InvocationId, fileId: NodeId, userId: UserId, newPermission: Int  ::
//         exists changeOwnerPermissionCall: CallId ::
//             changeOwnerPermissionCall.op == Op(files(NestedOp(fileId, owner_bit(Assign(newPermission)))))
//         &&  changeOwnerPermissionCall.origin == changeOwnerPermissionInvocation
//         &&  changeOwnerPermissionInvocation.info == changeOwnerPermission(userId, newPermission, fileId)
//         &&  changeOwnerPermissionInvocation.result == changeOwnerPermission_res(true)
//         ==>                                                               
//             !exists assignAdmin: CallId ::
//                     assignAdmin.op == Op(users(NestedOp(userId, is_admin(Assign(true)))))
//                 &&  assignAdmin happened before changeOwnerPermissionCall
//             &&  
//             !exists changeOwner: CallId ::
//                     changeOwner.op ==  Op(files(NestedOp(fileId, file_owner(Assign(userId)))))
//                 &&  changeOwner is visible
// ////


// /**
//  * Conflicting same action from and admin and a regular user
//  *  Runtime error here.
//  */
// invariant forall changeOwnerPermissionAdminInvocation: InvocationId, changeOwnerPermissionUserInvocation: InvocationId ::
//         exists changeOwnerPermissionAdminCall: CallId, changeOwnerPermissionUserCall: CallId, adminId: UserId, userId: UserId, adminPermissions: Int, userPermissions:Int, fileId: NodeId ::
//                 changeOwnerPermissionAdminCall.op == Op(files(NestedOp(fileId, owner_bit(Assign(adminPermissions)))))
//             &&  changeOwnerPermissionUserCall.op == Op(files(NestedOp(fileId, owner_bit(Assign(userPermissions)))))
//             &&  changeOwnerPermissionAdminCall.origin == changeOwnerPermissionAdminInvocation
//             &&  changeOwnerPermissionUserCall.origin == changeOwnerPermissionUserInvocation
//             &&  changeOwnerPermissionAdminInvocation.info == changeOwnerPermission(adminId, adminPermissions, fileId)
//             &&  changeOwnerPermissionUserInvocation.info == changeOwnerPermission(userId, userPermissions, fileId)
//             &&  adminPermissions != userPermissions
//             &&  usersQry(NestedQuery(adminId, is_adminQry(ReadRegister)))
//             &&  !usersQry(NestedQuery(userId, is_adminQry(ReadRegister)))
//             &&  changeOwnerPermissionAdminInvocation.result == changeGroupPermission_res(true) // admin success
//             &&  !(changeOwnerPermissionUserCall happened before changeOwnerPermissionAdminCall)
//             &&  !(changeOwnerPermissionAdminCall happened before changeOwnerPermissionUserCall)
//             //  TODO: might be different permissions but not conflicting, what then?
//             ==>
//               changeOwnerPermissionUserInvocation.result == changeOwnerPermission_res(false) // user can't defy admin
