// relax the requirment that when a user creates a file with a specific group, he/she has to be in that group. (repliss doesn't support this due to nested return types being not supported yet)


idtype NodeId
idtype UserId
idtype GroupId
type String

// type fileCreateResult =
//     NodeId | Nothing()

type AccessRight = 
      UNone() // 000
    | UR()  // 100
    | UW()  // 010
    | URW() // 110
    | ANone()
    | AR()
    | AW()
    | ARW()

// TODO: user directories and file names
// CRDT specifications
// this data will represent file and directory
// we name it file since we assumed directory is a file which has childrens (it can be non sence assumtion but we used it just to make it easy to accept the name)
crdt files: Map_dw[NodeId, {
    // name: Register[String],
    // this field will contain node id of directory. we can use it to find all childrens of directory
    //parent: Register[NodeId], to make things simple, we directory structure
    access_right_owner: AFileAccessRights[AccessRight],
    access_right_group: AFileAccessRights[AccessRight],
    access_right_other: AFileAccessRights[AccessRight],
    file_owner: Register[UserId],
    file_group: Register[GroupId],
    file_data: Register[UserId] // dummy data for establishing calls within the READ/WRITE/EXECUTE invocations to be able to use the happened before relation
}]
        
crdt groups: Map_dw[GroupId, {
    group_users: Set_rw[UserId],
    created: Register[Bool]
}]

crdt users: Map_uw[UserId, {
    is_admin: Register[Bool],
    user_group: Register[GroupId] // own group
}]


def changeOwner(userId: UserId, newOwnerId: UserId, fileId: NodeId): Bool
    atomic 
        if (filesQry(ContainsKey(fileId)))
            if (usersQry(ContainsKey(userId)) && (usersQry(NestedQuery(userId, is_adminQry(ReadRegister))) == true))
                call files(NestedOp(fileId, file_owner(Assign(newOwnerId))))
                return true
            else
                return false
        else 
            return false


def changeGroup(userId: UserId, newGroupId: GroupId, fileId: NodeId): Bool
    atomic
        if (filesQry(ContainsKey(fileId)))
            if(
                (usersQry(ContainsKey(userId)) && usersQry(NestedQuery(userId, is_adminQry(ReadRegister))) == true)
            )
                call files(NestedOp(fileId, file_group(Assign(newGroupId))))
                return true
            else
                return false
        else
            return false


def changeOwnerPermission(userId: UserId,  newPermission: AccessRight, fileId: NodeId): Bool
    atomic
        if (!usersQry(ContainsKey(userId)))
            return false

        if(!filesQry(ContainsKey(fileId)))
            return false

        if(usersQry(NestedQuery(userId, is_adminQry(ReadRegister))))
            call files(NestedOp(fileId, access_right_owner(Assign(newPermission))))
            return true
        else
            if(filesQry(NestedQuery(fileId, file_ownerQry(ReadRegister))) == userId)
                if(newPermission == UNone() || newPermission == UW() || newPermission == UR() || newPermission == URW())
                    call files(NestedOp(fileId, access_right_owner(Assign(newPermission))))
                    return true
                else
                    return false
            else 
                return false


def changeGroupPermission(userId: UserId, newPermission: AccessRight, fileId: NodeId): Bool
    atomic
        if (!usersQry(ContainsKey(userId)))
            return false

        if(!filesQry(ContainsKey(fileId)))
            return false

        if(usersQry(NestedQuery(userId, is_adminQry(ReadRegister))))
            call files(NestedOp(fileId, access_right_group(Assign(newPermission))))
            return true
        else
            if(filesQry(NestedQuery(fileId, file_ownerQry(ReadRegister))) == userId)
                if(newPermission == UNone() || newPermission == UW() || newPermission == UR() || newPermission == URW())
                    call files(NestedOp(fileId, access_right_group(Assign(newPermission))))
                    return true
                else
                    return false
            else 
                return false


def changeOtherPermission(userId: UserId, newPermission: AccessRight, fileId: NodeId): Bool
    atomic
        if (!usersQry(ContainsKey(userId)))
            return false

        if(!filesQry(ContainsKey(fileId)))
            return false

        if(usersQry(NestedQuery(userId, is_adminQry(ReadRegister))))
            call files(NestedOp(fileId, access_right_other(Assign(newPermission))))
            return true
        else
            if(filesQry(NestedQuery(fileId, file_ownerQry(ReadRegister))) == userId)
                if(newPermission == UNone() || newPermission == UW() || newPermission == UR() || newPermission == URW())
                    call files(NestedOp(fileId, access_right_other(Assign(newPermission))))
                    return true
                else
                    return false
            else 
                return false


def createFile(userId: UserId, groupId: GroupId): NodeId
    var f: NodeId
    atomic
        if ((usersQry(ContainsKey(userId))) && groupsQry(ContainsKey(groupId)))
            f = new NodeId
            // call file_name_assign(f, fileName) // file name
            call files(NestedOp(f, file_owner(Assign(userId)))) //associate a user
            call files(NestedOp(f, file_group(Assign(groupId)))) //associate group to user

            if(usersQry(NestedQuery(userId, is_adminQry(ReadRegister))))
                call files(NestedOp(f, access_right_owner(Assign(ARW())))) //default rwx for owner
                call files(NestedOp(f, access_right_group(Assign(AR())))) //default r   for group
                call files(NestedOp(f, access_right_other(Assign(AR())))) //default r   for other
            else
                call files(NestedOp(f, access_right_owner(Assign(URW())))) //default rwx for owner
                call files(NestedOp(f, access_right_group(Assign(UR())))) //default r   for group
                call files(NestedOp(f, access_right_other(Assign(UR())))) //default r   for other
            
            return f

        // return nothing (repliss extracts returned ids and append them as a list of created ids to quantify on, repliss also doesn't support returning composite types containing ids)

def readFile(userId: UserId, fileId: NodeId): Bool
    var ownerFilePerms: AccessRight
    var groupFilePerms: AccessRight
    var otherFilePerms: AccessRight
    var fileGroup: GroupId
    var data: UserId
    atomic
        if(!(filesQry(ContainsKey(fileId))))
            return false
            
        if(!usersQry(ContainsKey(userId)))
            return false
            
        if(usersQry(NestedQuery(userId, is_adminQry(ReadRegister))))
            data = filesQry(NestedQuery(fileId, file_dataQry(ReadRegister))) // establish a read
            return true

        if(filesQry(NestedQuery(fileId, file_ownerQry(ReadRegister))) == userId) // check if owner
            ownerFilePerms = filesQry(NestedQuery(fileId, access_right_ownerQry(ReadPermsLB)))
            if(ownerFilePerms == UR() || ownerFilePerms == URW() || ownerFilePerms == AR() || ownerFilePerms == ARW())
                data = filesQry(NestedQuery(fileId, file_dataQry(ReadRegister))) // establish a read
                return true
            else
                return false

        fileGroup = filesQry(NestedQuery(fileId, file_groupQry(ReadRegister)))
        if(groupsQry(NestedQuery(fileGroup, group_usersQry(Contains(userId)))))
            groupFilePerms = filesQry(NestedQuery(fileId, access_right_groupQry(ReadPermsLB)))
            if(groupFilePerms == UR() || groupFilePerms == URW() || groupFilePerms == AR() || groupFilePerms == ARW())
                data = filesQry(NestedQuery(fileId, file_dataQry(ReadRegister))) // establish a read
                return true
            else
                return false
            
        //otherwise user is other
        otherFilePerms = filesQry(NestedQuery(fileId, access_right_otherQry(ReadPermsLB)))
        if(otherFilePerms == UR() || otherFilePerms == URW() || otherFilePerms == AR() || otherFilePerms == ARW())
            data = filesQry(NestedQuery(fileId, file_dataQry(ReadRegister))) // establish a read
            return true
        else
            return false


def writeFile(userId: UserId, fileId: NodeId): Bool
    var ownerFilePerms: AccessRight
    var groupFilePerms: AccessRight
    var otherFilePerms: AccessRight
    var fileGroup: GroupId
    var data: UserId
    atomic
        if(!(filesQry(ContainsKey(fileId))))
            return false
            
        if(!usersQry(ContainsKey(userId)))
            return false
            
        if(usersQry(NestedQuery(userId, is_adminQry(ReadRegister))))
            call files(NestedOp(fileId, file_data(Assign(userId)))) // establish a write
            return true

        if(filesQry(NestedQuery(fileId, file_ownerQry(ReadRegister))) == userId) // check if owner
            ownerFilePerms = filesQry(NestedQuery(fileId, access_right_ownerQry(ReadPermsLB)))
            if(ownerFilePerms == UW() || ownerFilePerms == URW() || ownerFilePerms == AW() || ownerFilePerms == ARW())
                call files(NestedOp(fileId, file_data(Assign(userId)))) // establish a write
                return true
            else
                return false

        fileGroup = filesQry(NestedQuery(fileId, file_groupQry(ReadRegister)))
        if(groupsQry(NestedQuery(fileGroup, group_usersQry(Contains(userId)))))
            groupFilePerms = filesQry(NestedQuery(fileId, access_right_groupQry(ReadPermsLB)))
            if(groupFilePerms == UW() || groupFilePerms == URW() || groupFilePerms == AW() || groupFilePerms == ARW())
                call files(NestedOp(fileId, file_data(Assign(userId)))) // establish a write
                return true
            else
                return false
            
        //otherwise user is other
        otherFilePerms = filesQry(NestedQuery(fileId, access_right_otherQry(ReadPermsLB)))
        if(otherFilePerms == UW() || otherFilePerms == URW() || otherFilePerms == AW() || otherFilePerms == ARW())
            call files(NestedOp(fileId, file_data(Assign(userId)))) // establish a write
            return true
        else
            return false


def createUser(with_admin_rights: Bool) : UserId
    var u: UserId
    atomic
        u = new UserId
        call users(NestedOp(u, is_admin(Assign(with_admin_rights))))
        //call users(NestedOp(u, user_group(Assign(g))))
        return u


def createGroup() : GroupId
    var g: GroupId
    atomic
        g = new GroupId
        call groups(NestedOp(g, created(Assign(true))))
        return g


def assignUserToGroup(authorId: UserId, groupId: GroupId, userId: UserId) : Bool
    atomic
        if(usersQry(ContainsKey(authorId)) && (usersQry(NestedQuery(authorId, is_adminQry(ReadRegister))) == true) && usersQry(ContainsKey(userId)) && groupsQry(ContainsKey(groupId)))
            call groups(NestedOp(groupId, group_users(Add(userId))))
            return true
        else
            return false


def removeUserFromGroup(adminId: UserId, userId: UserId, groupId: GroupId) : Bool
    atomic
        if (usersQry(ContainsKey(adminId)) && usersQry(NestedQuery(adminId, is_adminQry(ReadRegister))) && usersQry(ContainsKey(userId)))
            call groups(NestedOp(groupId, group_users(Remove(userId))))
            return true
        else
            return false




// An access policy for an owner to a file is defined by the pair of (OwnerSet ----> AccessRightOwner) that directly precede the write
invariant forall fileId: NodeId, fileOwnerId: UserId, readInvocation: InvocationId ::
            readInvocation.info == readFile(fileOwnerId, fileId) // all the reads that happen after the policy change (protection is applicable)
        &&  readInvocation.result != NoResult()
        ==>
            forall  changePermissionCall: CallId, changePermissionInvocation: InvocationId, someAccessRight: AccessRight::
                    (someAccessRight == AW() || someAccessRight == ANone() || someAccessRight == UW() || someAccessRight == UNone()) // at least one of them takes away the read since it is a lower bound
                &&  changePermissionCall.op == Op(files(NestedOp(fileId, access_right_owner(Assign(someAccessRight)))))
                &&  changePermissionCall.origin == changePermissionInvocation 
                &&  changePermissionInvocation happened before readInvocation
                &&  (
                        (
                            exists adminOrOwner: UserId ::
                                    changePermissionInvocation.info == changeOwnerPermission(adminOrOwner, someAccessRight, fileId) 
                                &&  changePermissionInvocation.result == changeOwnerPermission_res(true)
                        )
                        ||  (
                            exists  fileCreatorId: UserId, fileOriginalGroupId: GroupId ::
                                    changePermissionInvocation.info == createFile(fileCreatorId, fileOriginalGroupId)
                                &&  changePermissionInvocation.result == createFile_res(fileId)
                        )
                    )
                ==>
                    forall changeOwnerCall: CallId, changeOwnerInvocation: InvocationId ::
                            changeOwnerCall.op == Op(files(NestedOp(fileId, file_owner(Assign(fileOwnerId))))) // quantify the file owner at the event of writing
                        &&  changeOwnerInvocation == changeOwnerCall.origin
                        &&  changeOwnerInvocation happened before readInvocation
                        &&  ((changeOwnerInvocation happened before changePermissionInvocation) || (changePermissionInvocation happened before changeOwnerInvocation) || changePermissionInvocation == changeOwnerInvocation)
                        && ( // only the immediate permission changes that precede
                            !exists anotherChangePermissionCall: CallId, anotherChangePermissionInvocation: InvocationId, someOtherAdminOrOwner: UserId, someOtherAccessRight: AccessRight ::
                                    anotherChangePermissionCall.op == Op(files(NestedOp(fileId, access_right_owner(Assign(someOtherAccessRight)))))
                                &&  anotherChangePermissionCall.origin == anotherChangePermissionInvocation
                                &&  anotherChangePermissionInvocation.result != NoResult()
                                &&  anotherChangePermissionInvocation happened before readInvocation
                                &&  anotherChangePermissionInvocation happened after changePermissionInvocation  
                                &&  (anotherChangePermissionInvocation happened before changeOwnerInvocation || anotherChangePermissionInvocation happened after changeOwnerInvocation)
                        )
                        && ( // the most recent owner of the file
                            !exists changeOwnerInBetweenCall: CallId, changeOwnerInBetweenInvocation: InvocationId, differentUserId: UserId ::
                                    changeOwnerInBetweenCall.op == Op(files(NestedOp(fileId, file_owner(Assign(differentUserId)))))  // change owner to `user`
                                &&  changeOwnerInBetweenInvocation == changeOwnerInBetweenCall.origin
                                &&  differentUserId != fileOwnerId
                                &&  changeOwnerInBetweenInvocation happened before readInvocation
                                &&  changeOwnerInBetweenInvocation happened after changeOwnerInvocation
                                &&  (changeOwnerInBetweenInvocation happened before changePermissionInvocation || changeOwnerInBetweenInvocation happened after changePermissionInvocation)           
                        )
                        && ( // this only applies for user
                             !exists assignAdminCall: CallId, assignAdminInvocation: InvocationId ::
                                    assignAdminCall.op == Op(users(NestedOp(fileOwnerId, is_admin(Assign(true)))))
                                &&  assignAdminInvocation == assignAdminCall.origin 
                                &&  assignAdminInvocation happened before changeOwnerInvocation
                                &&  assignAdminInvocation happened before changePermissionInvocation
                        )
                        ==>
                            readInvocation.result == readFile_res(false)


//invariant !exists fileId: NodeId, fileOwnerId: UserId, readInvocation: InvocationId ::
//            readInvocation.info == readFile(fileOwnerId, fileId)
//        &&  readInvocation.result != NoResult()